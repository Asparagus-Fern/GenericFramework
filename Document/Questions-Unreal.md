##### ue中，正向是坐标系中的哪个轴

UE 采用的是左手坐标系，默认的前向轴是Y轴的正方向，右向轴是X轴的正方向，上向轴是Z轴的正方向。


##### 在场景中创建actor的方法

1. 在编辑器中直接放置
2. 运行时动态创建：Spawn Actor


##### 向蓝图暴露变量的宏是哪个？

| 说明符              | 作用                                             |
| ------------------- | ------------------------------------------------ |
| EditAnywhere        | 变量在编辑器属性面板中可编辑（原型和实例均生效） |
| EditDefaultsOnly    | 变量在编辑器属性面板中可编辑（原型生效）         |
| EditInstanceOnly    | 变量在编辑器属性面板中可编辑（实例均生效）       |
| VisibleAnywhere     | 变量在属性面板可见但不可编辑（原型和实例均生效） |
| VisibleDefaultsOnly | 变量在属性面板可见但不可编辑（原型均生效）       |
| VisibleInstanceOnly | 变量在属性面板可见但不可编辑（实例均生效）       |
| BlueprintReadWrite  | 蓝图可读取和修改该变量（自动生成get/set逻辑）    |
| BlueprintReadOnly   | 蓝图仅可读取该变量（不可修改）                   |


##### ue中如何创建uobject对象

核心创建方法：使用 NewObject<>() 模板函数

UObject由虚幻引擎自动回收。如果创建后未被引用（如未添加到`UPROPERTY()`变量或全局对象树中），下一轮GC时会被销毁。

NewObject必须在游戏线程调用，不可在子线程中创建UObject。

使用 IsValid() 而非 nullptr 检查（UE 特有的无效对象系统）


##### 阐述下gamemode在ue框架中的意义

1. 定义了游戏的核心规则
2. 定义游戏使用的核心类：DefaultPawnClass（玩家角色）、PlayerControllerClass（玩家控制器）、HUDClass（界面）等
3. 在多人游戏中，GameMode 仅在服务器端实例化，客户端无法直接访问其变量或函数
4. 每个关卡（Level）运行时都会加载一个关联的 GameMode 实例
5. 处理玩家登录/退出（PostLogin、Logout）和控制玩家生成逻辑（SpawnDefaultPawnAtTransform、RestartPlayer）
6. 管理游戏状态切换（如开始、暂停、结束）


##### 如何使用charactermovement飞行？

将Default Movement Mode设为Flying


##### FString,FName,FText的使用场景举例下

| FString |                                                                   存储为UTF-16编码（在内存中为TCHAR数组，根据平台可能是2字节或4字节，但通常为2字节）<br /> 可变的，支持动态操作（如连接、查找、替换等）<br />操作灵活但开销较大（内存分配频繁）                                                                   |
| ------- | :----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------: |
| FName   | 代表一个不区分大小写的名称，通常用于内部资源引用<br /> 通过一个全局名称表（Name Table）进行存储，每个唯一的名称只存储一次，后续相同的名称会指向同一个存储位置<br />比较两个FName只需要比较索引（指针比较）而不需要比较字符串内容<br />不区分大小写，并且会去除空格等多余字符（在创建时会被转换为小写并存储在表中） |
| FText   |                                              用于本地化文本（支持多语言）和格式化文本<br /> 不可变，但支持创建本地化字符串、格式化（如数字、日期、时间等）<br />内部使用引用计数，可以高效地传递（因为是只读的）<br />支持本地化查找（通过键来获取对应语言的字符串）                                              |


##### CDO class default object

代表一个UClass的默认对象模板：每个继承自 UObject 的类（如 AActor、UBlueprintGeneratedClass）在程序启动时，会自动生成一个全局唯一的默认实例，该实例存储了该类的默认属性值

1. 提供对象初始值
2. 蓝图默认值同步：蓝图中修改的属性值（如角色初始血量）会被编译到其生成的CDO中
3. 配置继承：类CDO自动继承父类CDO的属性值
4. C++构造函数仅在生成CDO时执行一次（非每个实例创建时都执行）

| C++类   | 模块加载时（如游戏启动/模块热重载时），执行 static ConstructorHelpers::FClassFinder 或构造函数  |
| ------- | ----------------------------------------------------------------------------------------------- |
| 蓝图类  | 蓝图编译后生成，属性值来自蓝图编辑器中设置的默认值                                              |


##### 请简述GameMode,GameState,PlayerState，PlayerController,Pawn的功能和相互的关系

|    游戏框架类    |                                                     功能                                                     | 存在位置           |
| :--------------: | :-----------------------------------------------------------------------------------------------------------: | ------------------ |
|     GameMode     |             仅在服务器存在（客户端无访问权限）<br />定义游戏规则，控制游戏流程<br />管理玩家生成             | 仅服务器           |
|    GameState    |                     同步到所有客户端<br />存储全局游戏状态<br />可以访问到所有PlayerState                     | 服务器+所有客户端  |
|   PlayerState   |                     同步到所有客户端<br />存储玩家个人状态<br /> 每个玩家独立拥有一个实例                     | 服务器+所有客户端  |
| PlayerController |                       玩家输入处理<br /> 管理玩家视角<br />在服务器和客户端各有一个实例                       | 服务器+所属客户端  |
|       Pawn       | 玩家在游戏世界中的物理代表<br /> 处理移动、碰撞、动画等基础行为<br />被 PlayerController 或 AIController 控制 | 服务器+所有客户端  |


##### Gamelnstance 的功能有哪些，一共可以存在多少个

|   全局数据存储   |                       跨关卡数据传递：在切换关卡时保留临时数据（如玩家进度、关卡解锁状态），但不适用于永久存储（需使用 SaveGame）<br />网络与会话管理：处理网络会话（Session）的创建、加入和销毁，维护TCP/UDP等持久连接                       | col3 |
| :--------------: | :--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------: | ---- |
|     全局逻辑     |                                                                                实现独立于关卡的逻辑（如排行榜更新、成就系统），通过 GetGameInstance() 全局访问                                                                                |      |
|    UI系统管理    |                                                                                       全局管理复杂UI的创建与切换（如主菜单、设置界面），避免重复生成资源                                                                                       |      |
| 生命周期事件处理 |                                         初始化与关闭：在游戏启动时执行初始化逻辑（如加载配置），退出时清理资源<br /> 错误处理：捕获网络错误（NetWorkError）和关卡切换错误（TravelError），提供回调接口                                         |      |
|     存在数量     | 独立游戏：1个	整个游戏进程唯一，从启动持续到退出<br />多人游戏：服务器1个 + 每位客户端1个	服务器和每个客户端均有独立实例，数据不自动同步<br />PIE模式（编辑器）：多个（每个PIE窗口1个）	每个Play-in-Editor实例独立运行，拥有自己的GameInstance |      |


##### Selector、Sequence的节点功能

| Selector | 按从左到右的顺序依次执行子节点，直到找到一个成功的子节点<br />一旦某个子节点返回Success，立即停止后续子节点的执行，并向上层返回Success<br />若所有子节点均返回Failure，则自身返回Failure |
| :-------: | :--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------: |
| Sequence  |      按从左到右的顺序依次执行子节点，要求所有子节点均成功<br /> 若某个子节点返回Failure，立即终止后续执行，并向上层返回Failure<br />仅当所有子节点均返回Success时，自身返回Success      |


##### 在C++和蓝图中如何打印调试信息，c++请写出代码，蓝图请写出节点名称

|  使用UE_LOG输出到日志  |             UE_LOG(LogTemp, Warning, TEXT("Your message here, %s"), *YourVariable);             |
| :--------------------: | :---------------------------------------------------------------------------------------------: |
| 使用GEngine输出到屏幕  | GEngine->AddOnScreenDebugMessage(-1, 5.f, FColor::Red, TEXT("This is an on-screen message!"));  |
|  蓝图中打印调试信息   |            在蓝图中，常用的节点是`Print String`，它可以将字符串打印到屏幕和输出日志             |


##### UObject和AActor有什么区别？

|              |                                           UObject                                           |                                                     AActor                                                     |
| :-----------: | :-----------------------------------------------------------------------------------------: | :------------------------------------------------------------------------------------------------------------: |
|   继承关系    | 是所有Unreal对象（包括Actor、Component等）的基类。它提供了反射、垃圾回收、序列化等基础设施  | 继承自`UObject`，是场景中可放置对象的基类（如角色、灯光、摄像机等）。Actor可以包含多个组件（UActorComponent）  |
|   功能定位    |              是引擎对象系统的基石，但不具备场景表现能力（如位置、旋转、缩放）               |                         代表游戏世界中具有位置、旋转等空间属性的实体，可以被放入关卡                          |
| 生命周期管理  |                                   受引擎垃圾回收机制管理                                    |    受引擎垃圾回收机制管理<br /> 额外的生命周期控制：`Destroy()`方法会将其标记为待销毁（实际销毁由引擎处理）    |
|   网络同步    |                                       不支持网络复制                                        |                          支持网络同步（通过属性复制和RPC），是多人游戏的核心同步单位                           |
|   组件挂载    |                                    不能直接挂载场景组件                                     |                   可通过`RootComponent`组织组件树（如USceneComponent、UPrimitiveComponent）                    |
|   创建方式    |               使用`NewObject()`或`CreateDefaultSubobject()`（仅限构造函数）                |                                      必须通过`UWorld::SpawnActor()`生成                                       |
|  编辑器交互   |             可在内容浏览器中作为资产存在（如材质、数据表），但不能直接拖入场景              |                                 可被拖拽到关卡中，并拥有详细的编辑器属性面板                                  |


##### BlueprintlmplementableEvent 和BlueprintNativeEvent 的区别

|              | BlueprintlmplementableEvent |          BlueprintNativeEvent          |
| :-----------: | :-------------------------: | :-------------------------------------: |
|   C++实现    |    不能在C++中实现函数体    |        必须在C++中提供默认实现         |
| 蓝图重写要求  |      必须在蓝图中实现       |       蓝图可选择性重写（非必须）        |
| 函数签名处理  |        直接声明函数         | 需添加_Implementation后缀的C++实现函数  |
|   调用机制    |   直接调用（无C++实现）    |       通过自动生成的包装函数调用        |
|   适用场景    |    完全由蓝图定制的逻辑     |    提供默认实现但允许蓝图扩展的逻辑     |


##### 如何在c++中实现Run On Server的函数声明并且在蓝图可调用?

1. 声明函数：使用 UFUNCTION 宏和 Server 说明符
2. 添加实现：创建对应的 _Implementation 函数
3. 添加验证（可选）：使用 WithValidation 说明符


##### 虚幻引擎中的垃圾回收机制是如何的（GC）

核心流程：

1. 标记阶段（Marking）：从根集（Root Set）开始，利用UProperty信息精确识别引用链。UClass生成的Token Stream记录了每个类的指针偏移位置，使GC能快速遍历所有引用，完成可达性分析
2. 清除阶段（Sweeping）：采用增量式（Incremental Purge）避免卡顿。未被标记的对象最终调用析构函数并释放内存
   ConditionalBeginDestroy() → 触发BeginDestroy()（资源释放）
   ConditionalFinishDestroy() → 触发FinishDestroy()（内存回收）

线程安全方面：
GC与异步加载共享GUObjectArray全局锁，互斥执行
当GC等待异步加载锁超过最大尝试次数（NumberOfRetriesBeforeForcingGC）时，将强制中断异步加载并执行GC，防止主线程卡死或内存溢出

手动触发GC：GEngine->ForceGarbageCollection(true); 默认每60秒自动触发，可通过项目设置调整

常见错误：
裸指针陷阱：非UPROPERTY修饰的UObject*无法保护目标对象，导致不可预测回收
网络同步对象：需通过GetLifetimeReplicatedProps配置复制属性，确保客户端引用有效


##### 虚幻引擎中的反射是什么，你有使用过反射么？

反射（Reflection） 是支撑引擎动态运行时能力的核心机制，它允许程序在运行时获取类型信息（如类结构、属性、函数）并动态操作对象

| 核心组件                  | 功能                                             |
| ------------------------- | ------------------------------------------------ |
| UHT (Unreal Header Tool)  | 预处理C++头文件，生成.generated.h/.cpp反射代码   |
| GUObjectArray             | 全局对象池，存储所有UObject及其反射元数据        |
| 元数据系统                | 存储附加信息（如Category="AI"、ToolTip="血量"）  |

* 动态自省：运行时获取类名、继承关系、成员变量和函数签名等元数据
* 动态调用：无需编译期绑定，通过函数名字符串调用方法（如蓝图调用C++函数）
* 序列化基础：自动将对象状态保存/加载（如关卡保存、网络复制）
* 编辑器集成：属性面板、细节面板、蓝图节点生成均依赖反射数据

UHT（Unreal Header Tool） 和 UBT（Unreal Build Tool） 是两个核心的编译工具，它们协同工作以实现引擎的跨平台编译和反射系统支持

| UHT（Unreal Header Tool）                                                                                                                                                                           | UBT（Unreal Build Tool）                                                                                                                                                                                  |
| --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 解析C++头文件中的宏标记（如 UCLASS()、UFUNCTION()、UPROPERTY()）<br />生成对应的反射数据代码（.generated.h 和 .gen.cpp 文件）<br />生成的反射数据支撑蓝图交互、序列化、垃圾回收、网络复制等核心功能 | 使用C#编写，协调整个编译过程：调用UHT生成反射代码 → 调用本地编译器（如MSBuild）编译C++代码 → 链接二进制文件<br /> 通过解析 Target.cs 和 Build.cs 配置文件，适配不同平台（Windows、Android等）的编译选项 |
| 扫描含 #include "FileName.generated.h" 的头文件<br /> 提取元数据（如类继承关系、属性类型、函数签名），生成静态注册函数和属性布局信息                                                                | 分析模块依赖关系，确保编译顺序正确                                                                                                                                                                        |
