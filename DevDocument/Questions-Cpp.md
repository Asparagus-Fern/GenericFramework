##### cpp中动态库和静态库区别

|                |                                                   静态库                                                   |                                                     动态库                                                     |
| :------------: | :--------------------------------------------------------------------------------------------------------: | :------------------------------------------------------------------------------------------------------------: |
| 链接时机与方式 | 在编译链接阶段，库代码被完整复制到最终的可执行文件中。<br />生成的可执行文件是独立的，不再需要原始库文件。 | 编译时只记录库的引用信息，实际链接发生在程序运行时。<br />可执行文件必须与库文件一起分发，行时由操作系统加载库 |
|    文件体积    |                             静态库会使可执行文件体积显著增大（因为包含库代码）                             |                                    动态库生成较小的可执行文件（只包含引用）                                    |
|    内存占用    |                                  每个进程独立加载库代码副本，内存利用率低                                  |                                  多个进程可共享同一份库代码，显著减少内存占用                                  |
|    更新维护    |                         库更新需重新编译所有依赖程序<br /> 部署简单（单文件分发）                         |       可独立更新库文件（需保持接口兼容）<br /> 支持热更新和模块化设计<br />部署需确保库文件在系统路径中       |
|    依赖管理    |                              无运行时依赖问题<br /> 避免版本冲突（DLL Hell）                              |              需管理库文件路径（如 Linux 的 LD_LIBRARY_PATH）<br /> 可能因版本不兼容导致运行时错误              |
|   跨使用场景   |                 小型工具程序<br />避免依赖问题的封闭系统<br />对磁盘/内存占用不敏感的场景                 |            大型软件（如办公套件）<br />需要插件扩展的系统<br />频繁更新的公共组件<br />内存受限环境            |



---



##### cpp中指针是不是数据结构

在 C++ 里，指针并不属于数据结构，而是一种基础的数据类型。

指针是一种变量，其存储的数值是内存地址，该地址指向计算机内存中的另一个位置。通过这个内存地址，就能访问或者操作存储在该位置的数据。



---



##### cpp中定义常量使用宏还是const

在 C++ 中定义常量时，推荐优先使用const而非宏（#define）。

宏是预处理器指令，在编译前进行文本替换，没有类型检查和作用域限制。const是 C++ 的语言特性，用于声明编译期或运行期常量，具有类型安全和作用域规则。



---



##### 简单阐述下你认为运算符重载的意义

* 提升代码可读性：通过运算符重载，可以用直观的符号代替复杂的函数调用，使代码更接近数学表达式或自然语言。示例：复数加法
* 保持代码一致性：运算符重载使自定义类型的使用方式与内置类型保持一致，降低学习成本。示例：向量运算
* 实现自定义类型的自然操作：对于某些特殊类型，重载运算符能实现符合数学或业务逻辑的操作。示例：日期类的天数加减
* 增强标准库兼容性：重载运算符可以让自定义类型无缝集成到 C++ 标准库（如std::vector、std::cout）中。示例：重载<<用于流输出



---



##### 阐述下设计模式中单例模式的意义

单例模式（Singleton Pattern）是一种创建型设计模式，它确保一个类只有一个实例，并提供一个全局访问点来获取这个实例。其核心意义在于控制实例数量、避免资源竞争和简化全局访问。

* 控制实例数量：单例模式确保一个类在系统中仅存在一个实例，适用于需要严格控制资源的场景。
* 避免资源竞争：当多个实例可能引发资源冲突时，单例模式可以保证线程安全和数据一致性。
* 简化全局访问：单例模式提供了一个全局唯一的访问点，替代全局变量，避免命名空间污染。
* 提升系统可维护性：单例模式集中管理资源，使代码更易维护和测试。

|   适用场景   | 说明                                             |
| :----------: | ------------------------------------------------ |
|  资源管理器  | 文件系统、数据库连接池等，避免资源浪费和冲突。   |
| 全局状态管理 | 游戏中的玩家状态、应用配置等，确保状态一致性。   |
|    工具类    | 日期格式化工具、加密工具等，减少重复实例的开销。 |
|   硬件驱动   | 控制打印机、摄像头等硬件设备，防止多实例竞争。   |



---



##### 说一说你使用过得版本控制工具，描述下使用中的问题

|          | Git                                                                                                                                                                                                                                      | SVN                                                                                                                                                     |
| -------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 常见问题 | 分支管理混乱：多人协作时，若分支命名不规范或长期不合并，会导致分支爆炸。<br />解决方法：采用标准化分支模型（如 Git Flow、GitHub Flow），定期删除已合并分支。                                                                             | 服务器单点故障：所有操作依赖中央服务器，服务器宕机时无法进行提交、历史查看等操作。<br />解决方法：搭建热备服务器或使用云托管服务（如 AWS CodeCommit）。 |
|          | 合并冲突处理困难：当多人修改同一文件时，合并时可能产生复杂冲突。<br />解决方法：<br />  使用 git mergetool 等可视化工具辅助解决。<br />  遵循 “小而频繁” 的提交原则，减少冲突范围。<br />  优先使用 git rebase 保持线性提交历史。 | 分支与标签管理笨重：SVN 通过复制目录实现分支，创建和切换分支耗时较长。<br />解决方法：尽量减少分支使用，或迁移至分布式版本控制系统。                    |
|          | 误提交敏感信息：如密码、API Key 等被提交到仓库，即使删除仍可在历史中追溯。<br />解决方法：<br />  使用 .gitignore 提前排除敏感文件。<br />  若已提交，使用 git filter-repo 彻底删除历史记录。                                         | 权限管理复杂：基于路径的权限控制难以维护<br />解决方法：使用专用权限管理工具（如 VisualSVN Server）或迁移至 GitLab 等支持细粒度权限的平台。             |


---



##### cpp中，友元的优点和缺点

| 优点                                                                                                                                                                                                                         | 缺点                                                                                                                                                                                 |
| :--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | :----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 增强类间协作：当两个类需要紧密合作时，友元可以避免通过公共接口间接访问私有数据，提高效率。<br />典型场景：<br />  数据结构与算法分离：如迭代器访问容器的私有元素。<br />  运算符重载：如重载 << 运算符输出类的私有成员。 | 破坏封装性：友元可以访问私有成员，使类的封装边界被打破，增加了代码的耦合度。                                                                                                         |
| 实现细节隐藏：友元允许将部分实现逻辑放在类外部，同时保持私有成员不被公开。                                                                                                                                                   | 违反开闭原则：添加友元会修改类的定义，可能影响现有代码。                                                                                                                             |
| 优化性能：避免频繁调用访问器（getter/setter），直接操作数据成员。                                                                                                                                                            | 破坏继承关系：友元关系不可继承，可能导致设计复杂性。                                                                                                                                 |
|                                                                                                                                                                                                                              | 调试和维护困难：友元关系使访问权限分散，代码依赖变得不清晰。<br />典型场景：<br />  当多个类互为友元时，依赖关系错综复杂。<br />  修改私有成员可能影响多个友元类，增加测试负担。 |


---



##### 面相对象的特性

|      | 介绍                                                                                     | 关键点                                                                                                                                                                                        | 作用                                                                                                     |
| ---- | ---------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------- |
| 封装 | 将数据（属性）和操作数据的方法（行为）绑定在一起，<br />并通过访问控制隐藏内部实现细节。 | 访问控制：通过 private、protected、public 限定符控制成员的可见性。<br /> 数据隐藏：外部只能通过公开接口（方法）访问对象状态，避免直接修改数据。<br />模块化：降低类间依赖，提高代码可维护性。 | 保护数据：防止外部非法修改。<br /> 简化接口：使用者只需关注公开方法，无需了解内部实现。                  |
| 继承 | 基于已有类创建新类，实现代码复用和层次化组织。                                           | 基类（父类）与派生类（子类）：子类继承父类的属性和方法，可扩展或重写。<br /> 类型关系：子类对象可替代父类对象使用（里氏替换原则）。<br />访问控制：protected 成员可被子类访问，但外部不可见。 | 代码复用：避免重复实现通用功能（如 color 属性）。<br /> 多态基础：通过继承实现接口的统一和行为的差异化。 |
| 多态 | 同一接口表现出多种行为，通过继承和虚函数实现运行时绑定。                                 | 静态多态（编译时）：通过函数重载和模板实现。<br /> 动态多态（运行时）：通过虚函数（virtual）和指针 / 引用实现。<br />虚函数表：C++ 通过虚函数表（vtable）实现动态绑定。                       | 接口统一：通过基类指针 / 引用操作不同子类对象。<br /> 可扩展性：新增子类时无需修改现有代码（开闭原则）。 |
| 抽象 | 提取共性，忽略细节，定义高层接口。                                                       | 抽象类：包含纯虚函数的类，无法实例化，仅作为接口使用。<br /> 接口隔离：通过抽象类定义最小必要接口，避免子类依赖无关方法。                                                                     | 简化设计：隐藏底层实现，关注核心功能。<br /> 解耦依赖：依赖抽象而非具体实现（依赖倒置原则）。            |


---



##### 面相对象的设计原则

|               | 介绍                                                      | 关键点                                                                                                          |
| ------------- | --------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------- |
| 单一职责原则  | 一个类应该只有一个引起它变化的原因。                      | 每个类只负责一个特定的功能或职责。<br /> 避免 “大而全” 的类，防止职责扩散导致代码脆弱。                       |
| 开闭原则      | 软件实体（类、模块、函数等）应该对扩展开放，对修改关闭。  | 通过抽象（接口、抽象类）定义稳定接口，通过实现扩展行为。                                                        |
| 里氏替换原则  | 子类必须能够替换其父类而不影响程序的正确性。              | 子类应保持父类的行为契约（如方法参数、返回值、异常）。<br /> 避免子类削弱父类的功能（如抛出父类未声明的异常）。 |
| 接口隔离原则  | 客户端不应该依赖它不需要的接口。                          | 将庞大接口拆分为多个小而具体的接口。<br /> 避免类实现不需要的方法。                                             |
| 依赖倒置原则  | 高层模块不应该依赖低层模块，二者都应该依赖抽象。          | 依赖抽象（接口 / 抽象类）而非具体实现。<br /> 避免 “硬编码” 依赖关系，通过注入实现解耦。                      |
| 迪米特法则    | 一个对象应该对其他对象有最少的了解（只与直接朋友通信）。  | 避免访问 “陌生人” 对象（如 a.getB().getC().doSomething()）。<br /> 通过中间层（门面模式）减少对象间依赖。     |


---


##### 阐述下智能指针的实现手段和意义

智能指针是 C++ 中管理动态内存的重要工具，通过 RAII（资源获取即初始化）技术自动控制对象生命周期，解决裸指针的常见问题（内存泄漏、悬垂指针等）。

* *自动内存管理*：防止内存泄漏，尤其在有异常抛出时，也能确保资源释放。
* *明确所有权语义*：通过不同的智能指针类型清晰地表达资源的所有权（独占、共享、弱引用）。
* *异常安全*：由于资源自动释放，即使发生异常，也不会泄漏资源。
* *代码可读性和可维护性*：减少了手动 `new` 和 `delete` 的繁琐，使代码更清晰。

|                 | 实现关键                                                                                                                                                                                                                                                                                                                                                                                                                                                                              | 意义                                                                                                                                                                                          |
| --------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| std::unique_ptr | 独占所有权：一个对象只能由一个 `unique_ptr`拥有，不能复制，只能移动。<br /> 通过删除器（deleter）释放资源，默认使用 `delete`操作符。<br />内部通常包含一个指向所管理对象的原始指针和一个删除器（可能为空，如果使用默认删除器）。                                                                                                                                                                                                                                                  | 轻量级：几乎没有额外开销（与裸指针相比，只是在析构时自动释放）。                                                                                                                              |
| std::shared_ptr | 共享所有权：多个 `shared_ptr`可以共享同一个对象。当最后一个 `shared_ptr`被销毁时，对象才会被释放。<br /> 通过引用计数（reference counting）实现。通常，引用计数在堆上分配，由所有共享同一对象的 `shared_ptr`共享。<br />引用计数是线程安全的，通常使用原子操作来增减计数。<br />每个 `shared_ptr`包含两个指针：一个指向被管理对象，一个指向控制块（包含引用计数、弱引用计数、删除器等）。<br />控制块在第一个 `shared_ptr`创建时分配，当引用计数和弱引用计数都变为0时释放。 | 共享所有权：当多个对象需要共享同一资源时，`shared_ptr`可以确保资源在不再需要时被释放。                                                                                                        |
| std::weak_ptr   | 解决 `shared_ptr`循环引用问题。`weak_ptr`指向由 `shared_ptr`管理的对象，但不增加引用计数。 <br /> `weak_ptr`需要通过 `lock()`方法转换为 `shared_ptr`才能访问对象（如果对象还存在）。<br />包含指向控制块的指针，但控制块中的弱引用计数用于记录 `weak_ptr`的数量。<br />当强引用计数为0时，对象被销毁（即使弱引用计数不为0），但控制块直到弱引用计数也为0时才释放。<br />`weak_ptr`不管理对象的生命周期，因此不会阻止对象的销毁。                                     | 打破循环引用：当两个对象互相用 `shared_ptr`引用对方时，会导致引用计数永远不为0，从而内存泄漏。<br />提供临时访问：需要访问由 `shared_ptr`管理的对象而又不想拥有所有权（即不增加引用计数） |


---



##### 说出你认识的设计模式，阐述他们的特点

##### 针对接口编程的意义

##### 数组指针和指针数组区别

##### 指针数组加减一是否有意义？为什么？

##### cpp中头文件的意义

##### 内联函数的意义

##### 虚函数实现，虚函数表

##### 虚继承相关知识了解（菱形继承）

##### 指针和引用的区别

##### 进程和线程的区别

##### 共用体是什么？

##### C++中的多态是什么？

##### C++11特性列举一些

##### nullptr和NULL的区别

##### 宏编写逻辑体和使用函数的区别

##### 手写设计模式

##### main函数执行前后做了什么？

##### main函数为什么要返回数据整型

##### C++在普通平台的差异一般有哪些？简单说一下

##### 结构体中添加函数，在内存中如何分配？
